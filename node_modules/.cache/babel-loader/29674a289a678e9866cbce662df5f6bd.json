{"ast":null,"code":"import { useMemo } from 'react';\n\n/**\r\n * Credit to material-ui for this snippet\r\n */\nfunction setRef(ref, value) {\n  if (typeof ref === \"function\") {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n/**\r\n * useForkRef\r\n * Joins refs together and returns a combination of the two as a new ref\r\n *\r\n * @param refA\r\n * @param refB\r\n * @returns MutableRefObject\r\n * @see https://rooks.vercel.app/docs/useForkRef\r\n */\nfunction useForkRef(refA, refB) {\n  /**\r\n   * This will create a new function if the ref props change and are defined.\r\n   * This means react will call the old forkRef with `null` and the new forkRef\r\n   * with the ref. Cleanup naturally emerges from this behavior\r\n   */\n  return useMemo(() => {\n    if (refA === null && refB === null) {\n      return null;\n    }\n    return refValue => {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}\nexport { useForkRef };","map":{"version":3,"names":["useMemo","setRef","ref","value","undefined","current","useForkRef","refA","refB","refValue"],"sources":["/Users/lijinxing/Documents/hipo-dapp-bamboo/node_modules/rooks/dist/esm/hooks/useForkRef.js"],"sourcesContent":["import { useMemo } from 'react';\n\n/**\r\n * Credit to material-ui for this snippet\r\n */\r\nfunction setRef(ref, value) {\r\n    if (typeof ref === \"function\") {\r\n        ref(value);\r\n    }\r\n    else if (ref !== null && ref !== undefined) {\r\n        ref.current = value;\r\n    }\r\n}\r\n/**\r\n * useForkRef\r\n * Joins refs together and returns a combination of the two as a new ref\r\n *\r\n * @param refA\r\n * @param refB\r\n * @returns MutableRefObject\r\n * @see https://rooks.vercel.app/docs/useForkRef\r\n */\r\nfunction useForkRef(refA, refB) {\r\n    /**\r\n     * This will create a new function if the ref props change and are defined.\r\n     * This means react will call the old forkRef with `null` and the new forkRef\r\n     * with the ref. Cleanup naturally emerges from this behavior\r\n     */\r\n    return useMemo(() => {\r\n        if (refA === null && refB === null) {\r\n            return null;\r\n        }\r\n        return (refValue) => {\r\n            setRef(refA, refValue);\r\n            setRef(refB, refValue);\r\n        };\r\n    }, [refA, refB]);\r\n}\n\nexport { useForkRef };\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;;AAE/B;AACA;AACA;AACA,SAASC,MAAMA,CAACC,GAAG,EAAEC,KAAK,EAAE;EACxB,IAAI,OAAOD,GAAG,KAAK,UAAU,EAAE;IAC3BA,GAAG,CAACC,KAAK,CAAC;EACd,CAAC,MACI,IAAID,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKE,SAAS,EAAE;IACxCF,GAAG,CAACG,OAAO,GAAGF,KAAK;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,UAAUA,CAACC,IAAI,EAAEC,IAAI,EAAE;EAC5B;AACJ;AACA;AACA;AACA;EACI,OAAOR,OAAO,CAAC,MAAM;IACjB,IAAIO,IAAI,KAAK,IAAI,IAAIC,IAAI,KAAK,IAAI,EAAE;MAChC,OAAO,IAAI;IACf;IACA,OAAQC,QAAQ,IAAK;MACjBR,MAAM,CAACM,IAAI,EAAEE,QAAQ,CAAC;MACtBR,MAAM,CAACO,IAAI,EAAEC,QAAQ,CAAC;IAC1B,CAAC;EACL,CAAC,EAAE,CAACF,IAAI,EAAEC,IAAI,CAAC,CAAC;AACpB;AAEA,SAASF,UAAU"},"metadata":{},"sourceType":"module"}