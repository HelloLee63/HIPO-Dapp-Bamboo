{"ast":null,"code":"import { useState } from 'react';\nimport { useIntervalWhen } from './useIntervalWhen.js';\n\n/**\r\n *\r\n * useCountdown\r\n * Easy way to countdown until a given endtime in intervals\r\n *\r\n * @param endTime Time to countdown\r\n * @param options  Countdown options\r\n * @see https://rooks.vercel.app/docs/useCountdown\r\n */\nfunction useCountdown(endTime) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    interval = 1000,\n    onDown,\n    onEnd\n  } = options;\n  const [time, setTime] = useState(() => new Date());\n  const restTime = endTime.getTime() - time.getTime();\n  const count = restTime > 0 ? Math.ceil(restTime / interval) : 0;\n  useIntervalWhen(onTick, count ? interval : undefined, true, true);\n  return count;\n  function onTick() {\n    const newTime = new Date();\n    if (newTime > endTime) {\n      if (onEnd) {\n        onEnd(newTime);\n      }\n      setTime(endTime);\n      return;\n    }\n    if (onDown) {\n      onDown(restTime, newTime);\n    }\n    setTime(newTime);\n  }\n}\nexport { useCountdown };","map":{"version":3,"names":["useState","useIntervalWhen","useCountdown","endTime","options","arguments","length","undefined","interval","onDown","onEnd","time","setTime","Date","restTime","getTime","count","Math","ceil","onTick","newTime"],"sources":["/Users/lijinxing/Documents/hipo-dapp-bamboo/node_modules/rooks/dist/esm/hooks/useCountdown.js"],"sourcesContent":["import { useState } from 'react';\nimport { useIntervalWhen } from './useIntervalWhen.js';\n\n/**\r\n *\r\n * useCountdown\r\n * Easy way to countdown until a given endtime in intervals\r\n *\r\n * @param endTime Time to countdown\r\n * @param options  Countdown options\r\n * @see https://rooks.vercel.app/docs/useCountdown\r\n */\r\nfunction useCountdown(endTime, options = {}) {\r\n    const { interval = 1000, onDown, onEnd } = options;\r\n    const [time, setTime] = useState(() => new Date());\r\n    const restTime = endTime.getTime() - time.getTime();\r\n    const count = restTime > 0 ? Math.ceil(restTime / interval) : 0;\r\n    useIntervalWhen(onTick, count ? interval : undefined, true, true);\r\n    return count;\r\n    function onTick() {\r\n        const newTime = new Date();\r\n        if (newTime > endTime) {\r\n            if (onEnd) {\r\n                onEnd(newTime);\r\n            }\r\n            setTime(endTime);\r\n            return;\r\n        }\r\n        if (onDown) {\r\n            onDown(restTime, newTime);\r\n        }\r\n        setTime(newTime);\r\n    }\r\n}\n\nexport { useCountdown };\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,OAAO;AAChC,SAASC,eAAe,QAAQ,sBAAsB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,OAAO,EAAgB;EAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACvC,MAAM;IAAEG,QAAQ,GAAG,IAAI;IAAEC,MAAM;IAAEC;EAAM,CAAC,GAAGN,OAAO;EAClD,MAAM,CAACO,IAAI,EAAEC,OAAO,CAAC,GAAGZ,QAAQ,CAAC,MAAM,IAAIa,IAAI,EAAE,CAAC;EAClD,MAAMC,QAAQ,GAAGX,OAAO,CAACY,OAAO,EAAE,GAAGJ,IAAI,CAACI,OAAO,EAAE;EACnD,MAAMC,KAAK,GAAGF,QAAQ,GAAG,CAAC,GAAGG,IAAI,CAACC,IAAI,CAACJ,QAAQ,GAAGN,QAAQ,CAAC,GAAG,CAAC;EAC/DP,eAAe,CAACkB,MAAM,EAAEH,KAAK,GAAGR,QAAQ,GAAGD,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC;EACjE,OAAOS,KAAK;EACZ,SAASG,MAAMA,CAAA,EAAG;IACd,MAAMC,OAAO,GAAG,IAAIP,IAAI,EAAE;IAC1B,IAAIO,OAAO,GAAGjB,OAAO,EAAE;MACnB,IAAIO,KAAK,EAAE;QACPA,KAAK,CAACU,OAAO,CAAC;MAClB;MACAR,OAAO,CAACT,OAAO,CAAC;MAChB;IACJ;IACA,IAAIM,MAAM,EAAE;MACRA,MAAM,CAACK,QAAQ,EAAEM,OAAO,CAAC;IAC7B;IACAR,OAAO,CAACQ,OAAO,CAAC;EACpB;AACJ;AAEA,SAASlB,YAAY"},"metadata":{},"sourceType":"module"}