{"ast":null,"code":"import { useRef, useCallback, useEffect } from 'react';\nimport { useFreshRef } from './useFreshRef.js';\nimport { useGetIsMounted } from './useGetIsMounted.js';\n\n/**\r\n * A version of useEffect that accepts an async function\r\n *\r\n * @param {Effect<T>} effect Async function that can return a cleanup function and takes in an AbortSignal\r\n * @param {DependencyList} deps If present, effect will only activate if the values in the list change\r\n * @param {CleanupFunction} cleanup The destroy/cleanup function. Will be called with previous result if it exists.\r\n * @see https://rooks.vercel.app/docs/useAsyncEffect\r\n * @example\r\n * ```jsx\r\n * useAsyncEffect(\r\n        async (shouldContinueEffect) => {\r\n          const data1 = await fetchData1(arg1, arg2);\r\n          if(shouldContinueEffect()) {\r\n            const data2 = await fetchData2(arg1, arg2);\r\n          }\r\n          ...\r\n        },\r\n        [arg1, arg2],\r\n        (previousResult) => {\r\n          // ... do something with previousResult ...\r\n        }\r\n      );\r\n * ```\r\n */\nfunction useAsyncEffect(effect, deps, cleanup) {\n  // We need to synchronize the async callback response with\n  // the closure it was called in\n  const lastCallId = useRef(0);\n  const getIsMounted = useGetIsMounted();\n  const effectRef = useFreshRef(effect);\n  const callback = useCallback(async () => {\n    const callId = ++lastCallId.current;\n    const shouldContinueEffect = () => {\n      return getIsMounted() && callId === lastCallId.current;\n    };\n    try {\n      return await effectRef.current(shouldContinueEffect);\n    } catch (error) {\n      throw error;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [getIsMounted, ...deps]);\n  useEffect(() => {\n    let result;\n    callback().then(value => {\n      result = value;\n    });\n    return () => {\n      cleanup === null || cleanup === void 0 ? void 0 : cleanup(result);\n    };\n  }, [callback, cleanup]);\n}\nexport { useAsyncEffect };","map":{"version":3,"names":["useRef","useCallback","useEffect","useFreshRef","useGetIsMounted","useAsyncEffect","effect","deps","cleanup","lastCallId","getIsMounted","effectRef","callback","callId","current","shouldContinueEffect","error","result","then","value"],"sources":["/Users/lijinxing/Documents/hipo-dapp-bamboo/node_modules/rooks/dist/esm/hooks/useAsyncEffect.js"],"sourcesContent":["import { useRef, useCallback, useEffect } from 'react';\nimport { useFreshRef } from './useFreshRef.js';\nimport { useGetIsMounted } from './useGetIsMounted.js';\n\n/**\r\n * A version of useEffect that accepts an async function\r\n *\r\n * @param {Effect<T>} effect Async function that can return a cleanup function and takes in an AbortSignal\r\n * @param {DependencyList} deps If present, effect will only activate if the values in the list change\r\n * @param {CleanupFunction} cleanup The destroy/cleanup function. Will be called with previous result if it exists.\r\n * @see https://rooks.vercel.app/docs/useAsyncEffect\r\n * @example\r\n * ```jsx\r\n * useAsyncEffect(\r\n        async (shouldContinueEffect) => {\r\n          const data1 = await fetchData1(arg1, arg2);\r\n          if(shouldContinueEffect()) {\r\n            const data2 = await fetchData2(arg1, arg2);\r\n          }\r\n          ...\r\n        },\r\n        [arg1, arg2],\r\n        (previousResult) => {\r\n          // ... do something with previousResult ...\r\n        }\r\n      );\r\n * ```\r\n */\r\nfunction useAsyncEffect(effect, deps, cleanup) {\r\n    // We need to synchronize the async callback response with\r\n    // the closure it was called in\r\n    const lastCallId = useRef(0);\r\n    const getIsMounted = useGetIsMounted();\r\n    const effectRef = useFreshRef(effect);\r\n    const callback = useCallback(async () => {\r\n        const callId = ++lastCallId.current;\r\n        const shouldContinueEffect = () => {\r\n            return getIsMounted() && callId === lastCallId.current;\r\n        };\r\n        try {\r\n            return await effectRef.current(shouldContinueEffect);\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, [getIsMounted, ...deps]);\r\n    useEffect(() => {\r\n        let result;\r\n        callback().then((value) => {\r\n            result = value;\r\n        });\r\n        return () => {\r\n            cleanup === null || cleanup === void 0 ? void 0 : cleanup(result);\r\n        };\r\n    }, [callback, cleanup]);\r\n}\n\nexport { useAsyncEffect };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,WAAW,EAAEC,SAAS,QAAQ,OAAO;AACtD,SAASC,WAAW,QAAQ,kBAAkB;AAC9C,SAASC,eAAe,QAAQ,sBAAsB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,MAAM,EAAEC,IAAI,EAAEC,OAAO,EAAE;EAC3C;EACA;EACA,MAAMC,UAAU,GAAGT,MAAM,CAAC,CAAC,CAAC;EAC5B,MAAMU,YAAY,GAAGN,eAAe,EAAE;EACtC,MAAMO,SAAS,GAAGR,WAAW,CAACG,MAAM,CAAC;EACrC,MAAMM,QAAQ,GAAGX,WAAW,CAAC,YAAY;IACrC,MAAMY,MAAM,GAAG,EAAEJ,UAAU,CAACK,OAAO;IACnC,MAAMC,oBAAoB,GAAGA,CAAA,KAAM;MAC/B,OAAOL,YAAY,EAAE,IAAIG,MAAM,KAAKJ,UAAU,CAACK,OAAO;IAC1D,CAAC;IACD,IAAI;MACA,OAAO,MAAMH,SAAS,CAACG,OAAO,CAACC,oBAAoB,CAAC;IACxD,CAAC,CACD,OAAOC,KAAK,EAAE;MACV,MAAMA,KAAK;IACf;IACA;EACJ,CAAC,EAAE,CAACN,YAAY,EAAE,GAAGH,IAAI,CAAC,CAAC;EAC3BL,SAAS,CAAC,MAAM;IACZ,IAAIe,MAAM;IACVL,QAAQ,EAAE,CAACM,IAAI,CAAEC,KAAK,IAAK;MACvBF,MAAM,GAAGE,KAAK;IAClB,CAAC,CAAC;IACF,OAAO,MAAM;MACTX,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACS,MAAM,CAAC;IACrE,CAAC;EACL,CAAC,EAAE,CAACL,QAAQ,EAAEJ,OAAO,CAAC,CAAC;AAC3B;AAEA,SAASH,cAAc"},"metadata":{},"sourceType":"module"}