{"ast":null,"code":"import { useState, useCallback } from 'react';\n\n/* eslint-disable no-negated-condition */\nfunction warnIfBothValueAndIndexAreProvided(functionName, object) {\n  if (Object.values(object).every(value => typeof value !== \"undefined\")) {\n    console.warn(`${functionName}. Expected either ${Object.keys(object).join(\" or \")} to be provided. However all were provided`);\n  } else if (Object.values(object).every(value => typeof value === \"undefined\")) {\n    console.warn(`${functionName}. ${Object.keys(object).join(\" , \")} are all undefined.`);\n  }\n}\n/**\r\n * useMultiSelectableList\r\n * A custom hook to easily select multiple values from a list\r\n *\r\n * @param list - The list of values to select from\r\n * @param initialSelectIndices - The indices of the initial selections\r\n * @param allowUnselected - Whether or not to allow unselected values\r\n * @see https://rooks.vercel.app/docs/useMultiSelectableList\r\n */\nfunction useMultiSelectableList() {\n  let list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let initialSelectIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];\n  let allowUnselected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const [currentIndices, setCurrentIndices] = useState(initialSelectIndices);\n  const currentValues = currentIndices.map(index => list[index]);\n  const selection = [currentIndices, currentValues];\n  const updateSelections = _ref => {\n    let {\n      indices,\n      values\n    } = _ref;\n    return () => {\n      warnIfBothValueAndIndexAreProvided(\"updateSelections\", {\n        indices,\n        values\n      });\n      if (typeof indices !== \"undefined\") {\n        if (!allowUnselected && indices.length === 0) {\n          console.warn(`updateSelections failed. indices is an empty list.`);\n          return;\n        }\n        setCurrentIndices(indices);\n      } else if (typeof values !== \"undefined\") {\n        const valueIndices = list.reduce((accumulator, current, index) => {\n          if (values.includes(current)) {\n            const array = [...accumulator, index];\n            return array;\n          }\n          return accumulator;\n        }, []);\n        if (valueIndices.length > 0) {\n          setCurrentIndices(valueIndices);\n        } else if (allowUnselected) {\n          setCurrentIndices(valueIndices);\n        } else {\n          console.warn(`updateSelections failed. Do the values exist in the list?`);\n        }\n      }\n    };\n  };\n  const toggleSelectionByIndex = useCallback(index => {\n    let newIndices;\n    if (!currentIndices.includes(index)) {\n      newIndices = [...currentIndices, index];\n    } else {\n      newIndices = [...currentIndices];\n      const indexOfIndex = currentIndices.indexOf(index);\n      if (indexOfIndex !== -1) {\n        newIndices.splice(indexOfIndex, 1);\n      }\n    }\n    if (newIndices.length > 0) {\n      setCurrentIndices(newIndices);\n    } else if (allowUnselected) {\n      setCurrentIndices(newIndices);\n    } else {\n      console.warn(`toggleSelection failed. Do the values exist in the list?`);\n    }\n  }, [allowUnselected, currentIndices]);\n  const toggleSelection = useCallback(_ref2 => {\n    let {\n      index,\n      value\n    } = _ref2;\n    return () => {\n      warnIfBothValueAndIndexAreProvided(\"toggleSelection\", {\n        index,\n        value\n      });\n      if (typeof index !== \"undefined\") {\n        toggleSelectionByIndex(index);\n      } else if (typeof value !== \"undefined\") {\n        const valueIndex = list.indexOf(value);\n        if (valueIndex > -1) {\n          toggleSelectionByIndex(valueIndex);\n        }\n      }\n    };\n  }, [list, toggleSelectionByIndex]);\n  const matchSelection = useCallback(_ref3 => {\n    let {\n      index,\n      value\n    } = _ref3;\n    warnIfBothValueAndIndexAreProvided(\"matchSelection\", {\n      index,\n      value\n    });\n    if (typeof index !== \"undefined\") {\n      return currentIndices.includes(index);\n    } else if (typeof value !== \"undefined\") {\n      return currentValues.includes(value);\n    }\n    return false;\n  }, [currentIndices, currentValues]);\n  const controls = {\n    matchSelection,\n    toggleSelection,\n    updateSelections\n  };\n  return [selection, controls];\n}\nexport { useMultiSelectableList };","map":{"version":3,"names":["useState","useCallback","warnIfBothValueAndIndexAreProvided","functionName","object","Object","values","every","value","console","warn","keys","join","useMultiSelectableList","list","arguments","length","undefined","initialSelectIndices","allowUnselected","currentIndices","setCurrentIndices","currentValues","map","index","selection","updateSelections","_ref","indices","valueIndices","reduce","accumulator","current","includes","array","toggleSelectionByIndex","newIndices","indexOfIndex","indexOf","splice","toggleSelection","_ref2","valueIndex","matchSelection","_ref3","controls"],"sources":["/Users/lijinxing/Documents/hipo-dapp-bamboo/node_modules/rooks/dist/esm/hooks/useMultiSelectableList.js"],"sourcesContent":["import { useState, useCallback } from 'react';\n\n/* eslint-disable no-negated-condition */\r\nfunction warnIfBothValueAndIndexAreProvided(functionName, object) {\r\n    if (Object.values(object).every((value) => typeof value !== \"undefined\")) {\r\n        console.warn(`${functionName}. Expected either ${Object.keys(object).join(\" or \")} to be provided. However all were provided`);\r\n    }\r\n    else if (Object.values(object).every((value) => typeof value === \"undefined\")) {\r\n        console.warn(`${functionName}. ${Object.keys(object).join(\" , \")} are all undefined.`);\r\n    }\r\n}\r\n/**\r\n * useMultiSelectableList\r\n * A custom hook to easily select multiple values from a list\r\n *\r\n * @param list - The list of values to select from\r\n * @param initialSelectIndices - The indices of the initial selections\r\n * @param allowUnselected - Whether or not to allow unselected values\r\n * @see https://rooks.vercel.app/docs/useMultiSelectableList\r\n */\r\nfunction useMultiSelectableList(list = [], initialSelectIndices = [0], allowUnselected = false) {\r\n    const [currentIndices, setCurrentIndices] = useState(initialSelectIndices);\r\n    const currentValues = currentIndices.map((index) => list[index]);\r\n    const selection = [currentIndices, currentValues];\r\n    const updateSelections = ({ indices, values }) => {\r\n        return () => {\r\n            warnIfBothValueAndIndexAreProvided(\"updateSelections\", {\r\n                indices,\r\n                values,\r\n            });\r\n            if (typeof indices !== \"undefined\") {\r\n                if (!allowUnselected && indices.length === 0) {\r\n                    console.warn(`updateSelections failed. indices is an empty list.`);\r\n                    return;\r\n                }\r\n                setCurrentIndices(indices);\r\n            }\r\n            else if (typeof values !== \"undefined\") {\r\n                const valueIndices = list.reduce((accumulator, current, index) => {\r\n                    if (values.includes(current)) {\r\n                        const array = [...accumulator, index];\r\n                        return array;\r\n                    }\r\n                    return accumulator;\r\n                }, []);\r\n                if (valueIndices.length > 0) {\r\n                    setCurrentIndices(valueIndices);\r\n                }\r\n                else if (allowUnselected) {\r\n                    setCurrentIndices(valueIndices);\r\n                }\r\n                else {\r\n                    console.warn(`updateSelections failed. Do the values exist in the list?`);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    const toggleSelectionByIndex = useCallback((index) => {\r\n        let newIndices;\r\n        if (!currentIndices.includes(index)) {\r\n            newIndices = [...currentIndices, index];\r\n        }\r\n        else {\r\n            newIndices = [...currentIndices];\r\n            const indexOfIndex = currentIndices.indexOf(index);\r\n            if (indexOfIndex !== -1) {\r\n                newIndices.splice(indexOfIndex, 1);\r\n            }\r\n        }\r\n        if (newIndices.length > 0) {\r\n            setCurrentIndices(newIndices);\r\n        }\r\n        else if (allowUnselected) {\r\n            setCurrentIndices(newIndices);\r\n        }\r\n        else {\r\n            console.warn(`toggleSelection failed. Do the values exist in the list?`);\r\n        }\r\n    }, [allowUnselected, currentIndices]);\r\n    const toggleSelection = useCallback(({ index, value }) => {\r\n        return () => {\r\n            warnIfBothValueAndIndexAreProvided(\"toggleSelection\", {\r\n                index,\r\n                value,\r\n            });\r\n            if (typeof index !== \"undefined\") {\r\n                toggleSelectionByIndex(index);\r\n            }\r\n            else if (typeof value !== \"undefined\") {\r\n                const valueIndex = list.indexOf(value);\r\n                if (valueIndex > -1) {\r\n                    toggleSelectionByIndex(valueIndex);\r\n                }\r\n            }\r\n        };\r\n    }, [list, toggleSelectionByIndex]);\r\n    const matchSelection = useCallback(({ index, value }) => {\r\n        warnIfBothValueAndIndexAreProvided(\"matchSelection\", { index, value });\r\n        if (typeof index !== \"undefined\") {\r\n            return currentIndices.includes(index);\r\n        }\r\n        else if (typeof value !== \"undefined\") {\r\n            return currentValues.includes(value);\r\n        }\r\n        return false;\r\n    }, [currentIndices, currentValues]);\r\n    const controls = {\r\n        matchSelection,\r\n        toggleSelection,\r\n        updateSelections,\r\n    };\r\n    return [selection, controls];\r\n}\n\nexport { useMultiSelectableList };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}