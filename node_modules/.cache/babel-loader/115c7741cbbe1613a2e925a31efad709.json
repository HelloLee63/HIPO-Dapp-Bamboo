{"ast":null,"code":"import Web3 from 'web3';\nimport EventEmitter from 'wolfy87-eventemitter';\nimport { WEB3_ERROR_VALUE } from './Web3Provider';\nimport { uniqueId, debounce } from 'lodash';\nimport { getGasValue } from './helpers/utils';\nexport class AbiTuple {\n  constructor(items) {\n    this.items = [];\n    this.items = items;\n  }\n}\nexport class AbiTupleArray {\n  constructor(items) {\n    this.items = [];\n    this.items = items;\n  }\n}\nexport function createAbiItem(name) {\n  let inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let outputs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return {\n    name,\n    type: 'function',\n    stateMutability: 'view',\n    inputs: inputs.map(type => {\n      if (type instanceof AbiTuple) {\n        return {\n          name: '',\n          type: 'tuple',\n          components: type.items.map(t => ({\n            name: '',\n            type: t\n          }))\n        };\n      } else if (type instanceof AbiTupleArray) {\n        return {\n          name: '',\n          type: 'tuple[]',\n          components: type.items.map(t => ({\n            name: '',\n            type: t\n          }))\n        };\n      }\n      return {\n        name: '',\n        type\n      };\n    }),\n    outputs: outputs.map(type => {\n      if (type instanceof AbiTuple) {\n        return {\n          name: '',\n          type: 'tuple',\n          components: type.items.map(t => ({\n            name: '',\n            type: t\n          }))\n        };\n      } else if (type instanceof AbiTupleArray) {\n        return {\n          name: '',\n          type: 'tuple[]',\n          components: type.items.map(t => ({\n            name: '',\n            type: t\n          }))\n        };\n      }\n      return {\n        name: '',\n        type\n      };\n    })\n  };\n}\nclass BatchRequestManager {\n  static addRequest(source, request) {\n    const {\n      currentProvider\n    } = source;\n    if (!currentProvider) {\n      return;\n    }\n    const {\n      requests\n    } = this;\n    let state = requests.get(currentProvider);\n    if (!state) {\n      state = {\n        busy: false,\n        collected: []\n      };\n      requests.set(currentProvider, state);\n    }\n    state.collected.push(request);\n    this.run();\n  }\n}\nBatchRequestManager.requests = new Map();\nBatchRequestManager.run = debounce(() => {\n  const {\n    requests\n  } = BatchRequestManager;\n  requests.forEach(async (state, provider) => {\n    if (state.busy) {\n      return;\n    }\n    const web3 = new Web3(provider);\n    let extractCount = 0;\n    let delay = 0;\n\n    // if (provider === PolygonHttpsWeb3Provider) {\n    //   extractCount = 20;\n    //   delay = 250;\n    // }\n\n    state.busy = true;\n    while (state.collected.length > 0) {\n      const toExtract = extractCount > 0 ? extractCount : state.collected.length;\n      const items = state.collected.splice(0, toExtract);\n      const batch = new web3.BatchRequest();\n      items.forEach(method => batch.add(method));\n      await batch.execute();\n      if (delay > 0) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n    state.busy = false;\n  });\n}, 250);\nclass Web3Contract {\n  constructor(abi, address, name) {\n    if (!address) {\n      throw new Error(`Invalid contract address (${name})`);\n    }\n    this._events = new EventEmitter();\n    this._abi = abi;\n    this.address = address;\n    this.name = name !== null && name !== void 0 ? name : address;\n    const web3 = new Web3();\n    this._callContract = new web3.eth.Contract(abi, address);\n    this._sendContract = new web3.eth.Contract(abi, address);\n  }\n\n  /// GETTERS\n  get writeFunctions() {\n    return this._abi.filter(r => r.type === 'function' && !r.constant);\n  }\n  get callProvider() {\n    return this._callContract.currentProvider;\n  }\n  get provider() {\n    return this._sendContract.currentProvider;\n  }\n\n  /// SETTERS\n  setCallProvider(provider) {\n    if (this._callContract.currentProvider !== provider) {\n      this._callContract.setProvider(provider);\n    }\n  }\n  setProvider(provider) {\n    if (this._sendContract.currentProvider !== provider) {\n      this._sendContract.setProvider(provider);\n    }\n  }\n  setAccount(account) {\n    if (this.account !== account) {\n      this.account = account;\n      this.emit(Web3Contract.UPDATE_ACCOUNT, account);\n    }\n  }\n\n  /// ASSERTION METHODS\n  assertAccount() {\n    if (!this.account) {\n      throw new Error('This operation requires wallet to be connected!');\n    }\n  }\n\n  /// REQUEST METHODS\n  batch(methods) {\n    if (methods.length === 0) {\n      return Promise.reject(new Error(`Empty list of methods for batch.`));\n    }\n    const promises = methods.map(batchMethod => {\n      return new Promise(resolve => {\n        var _batchMethod$methodAr, _batchMethod$callArgs;\n        this.call(batchMethod.method, (_batchMethod$methodAr = batchMethod.methodArgs) !== null && _batchMethod$methodAr !== void 0 ? _batchMethod$methodAr : [], (_batchMethod$callArgs = batchMethod.callArgs) !== null && _batchMethod$callArgs !== void 0 ? _batchMethod$callArgs : {}).then(value => {\n          var _batchMethod$transfor;\n          return resolve(((_batchMethod$transfor = batchMethod.transform) !== null && _batchMethod$transfor !== void 0 ? _batchMethod$transfor : x => x)(value));\n        }).catch(err => {\n          var _batchMethod$onError, _batchMethod$onError2;\n          return resolve((_batchMethod$onError = (_batchMethod$onError2 = batchMethod.onError) === null || _batchMethod$onError2 === void 0 ? void 0 : _batchMethod$onError2.call(batchMethod, err)) !== null && _batchMethod$onError !== void 0 ? _batchMethod$onError : undefined);\n        });\n      });\n    });\n    return Promise.all(promises);\n  }\n  call(method) {\n    let methodArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let callArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const contractMethod = this._callContract.methods[method];\n    if (!contractMethod) {\n      return Promise.reject(new Error(`Unknown method \"${method}\". (Ref. ${this.name}.${method})`));\n    }\n    if (!this._callContract.currentProvider) {\n      return Promise.reject(new Error(`Contract call failure. Missing call provider. (Ref. ${this.name}.${method})`));\n    }\n    return new Promise((resolve, reject) => {\n      const req = contractMethod(...methodArgs).call.request(callArgs, (err, value) => {\n        if (err) {\n          console.error(`Contract(${this.address}).${method}.call`, err);\n          return reject(err);\n        }\n        if (+value === WEB3_ERROR_VALUE) {\n          return Promise.reject(new Error(`Contract call failure. (Ref. ${this.name}.${method})`));\n        }\n        resolve(value);\n      });\n      BatchRequestManager.addRequest(this._callContract, req);\n    });\n  }\n  send(method) {\n    let methodArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let sendArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let gasPrice = arguments.length > 3 ? arguments[3] : undefined;\n    this.assertAccount();\n    const contractMethod = this._sendContract.methods[method];\n    if (!contractMethod) {\n      return Promise.reject(new Error(`Unknown method \"${method}\". (Ref. ${this.name}.${method})`));\n    }\n    if (!this._sendContract.currentProvider) {\n      return Promise.reject(new Error(`Contract send failure. Missing send provider. (Ref. ${this.name}.${method})`));\n    }\n    const _sendArgs = {\n      from: this.account,\n      gasPrice: gasPrice !== undefined ? getGasValue(gasPrice) : undefined,\n      ...sendArgs\n    };\n    const meta = {\n      id: uniqueId(`${method}:`),\n      sender: this,\n      method,\n      methodArgs,\n      sendArgs: _sendArgs\n    };\n    return contractMethod(...methodArgs).send(_sendArgs, async (err, txHash) => {\n      if (err) {\n        return;\n      }\n      this.emit('tx:hash', txHash, {\n        ...meta,\n        state: 'progress',\n        txHash\n      });\n    }).then(result => {\n      this.emit('tx:success', result, {\n        ...meta,\n        state: 'success',\n        result\n      });\n      return result;\n    }).catch(error => {\n      var _this$_sendContract$c;\n      (_this$_sendContract$c = this._sendContract.currentProvider) === null || _this$_sendContract$c === void 0 ? void 0 : _this$_sendContract$c.emit('send::error', error);\n      this.emit('tx:fail', error, {\n        ...meta,\n        state: 'fail',\n        error\n      });\n      return Promise.reject(error);\n    });\n  }\n\n  /// EVENT METHODS\n  on(event, listener) {\n    return this._events.on(event, listener);\n  }\n  once(event, listener) {\n    return this._events.once(event, listener);\n  }\n  off(event, listener) {\n    return this._events.off(event, listener);\n  }\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return this._events.emit(event, ...args);\n  }\n  onUpdateAccount(listener) {\n    return this.on('update:account', listener);\n  }\n  onUpdateData(listener) {\n    return this.on('update:data', listener);\n  }\n}\nWeb3Contract.UPDATE_ACCOUNT = 'update:account';\nWeb3Contract.UPDATE_DATA = 'update:data';\nexport default Web3Contract;","map":{"version":3,"names":["Web3","EventEmitter","WEB3_ERROR_VALUE","uniqueId","debounce","getGasValue","AbiTuple","constructor","items","AbiTupleArray","createAbiItem","name","inputs","arguments","length","undefined","outputs","type","stateMutability","map","components","t","BatchRequestManager","addRequest","source","request","currentProvider","requests","state","get","busy","collected","set","push","run","Map","forEach","provider","web3","extractCount","delay","toExtract","splice","batch","BatchRequest","method","add","execute","Promise","resolve","setTimeout","Web3Contract","abi","address","Error","_events","_abi","_callContract","eth","Contract","_sendContract","writeFunctions","filter","r","constant","callProvider","setCallProvider","setProvider","setAccount","account","emit","UPDATE_ACCOUNT","assertAccount","methods","reject","promises","batchMethod","_batchMethod$methodAr","_batchMethod$callArgs","call","methodArgs","callArgs","then","value","_batchMethod$transfor","transform","x","catch","err","_batchMethod$onError","_batchMethod$onError2","onError","all","contractMethod","req","console","error","send","sendArgs","gasPrice","_sendArgs","from","meta","id","sender","txHash","result","_this$_sendContract$c","on","event","listener","once","off","_len","args","Array","_key","onUpdateAccount","onUpdateData","UPDATE_DATA"],"sources":["/Users/lijinxing/Documents/hipo-dapp-bamboo/src/web3/web3Contract.js"],"sourcesContent":["import Web3 from 'web3';\nimport EventEmitter from 'wolfy87-eventemitter';\nimport { WEB3_ERROR_VALUE } from './Web3Provider';\nimport { uniqueId, debounce } from 'lodash'\nimport { getGasValue } from './helpers/utils';\n\nexport class AbiTuple {\n  items = [];\n\n  constructor(items) {\n    this.items = items;\n  }\n}\n\nexport class AbiTupleArray {\n  items = [];\n\n  constructor(items) {\n    this.items = items;\n  }\n}\n\nexport function createAbiItem(\n  name,\n  inputs = [],\n  outputs = [],\n) {\n  return {\n    name,\n    type: 'function',\n    stateMutability: 'view',\n    inputs: inputs.map(type => {\n      if (type instanceof AbiTuple) {\n        return {\n          name: '',\n          type: 'tuple',\n          components: type.items.map(t => ({ name: '', type: t })),\n        };\n      } else if (type instanceof AbiTupleArray) {\n        return {\n          name: '',\n          type: 'tuple[]',\n          components: type.items.map(t => ({ name: '', type: t })),\n        };\n      }\n\n      return { name: '', type };\n    }),\n    outputs: outputs.map(type => {\n      if (type instanceof AbiTuple) {\n        return {\n          name: '',\n          type: 'tuple',\n          components: type.items.map(t => ({ name: '', type: t })),\n        };\n      } else if (type instanceof AbiTupleArray) {\n        return {\n          name: '',\n          type: 'tuple[]',\n          components: type.items.map(t => ({ name: '', type: t })),\n        };\n      }\n\n      return { name: '', type };\n    }),\n  };\n}\n\nclass BatchRequestManager {\n  static requests = new Map();\n\n  static addRequest(source, request) {\n    const { currentProvider } = source;\n\n    if (!currentProvider) {\n      return;\n    }\n\n    const { requests } = this;\n\n    let state = requests.get(currentProvider);\n\n    if (!state) {\n      state = {\n        busy: false,\n        collected: [],\n      };\n      requests.set(currentProvider, state);\n    }\n\n    state.collected.push(request);\n\n    this.run();\n  }\n\n  static run = debounce(() => {\n    const { requests } = BatchRequestManager;\n\n    requests.forEach(async (state, provider) => {\n      if (state.busy) {\n        return;\n      }\n\n      const web3 = new Web3(provider);\n\n      let extractCount = 0;\n      let delay = 0;\n\n      // if (provider === PolygonHttpsWeb3Provider) {\n      //   extractCount = 20;\n      //   delay = 250;\n      // }\n\n      state.busy = true;\n\n      while (state.collected.length > 0) {\n        const toExtract = extractCount > 0 ? extractCount : state.collected.length;\n        const items = state.collected.splice(0, toExtract);\n\n        const batch = new web3.BatchRequest();\n        items.forEach(method => batch.add(method));\n        await batch.execute();\n\n        if (delay > 0) {\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n\n      state.busy = false;\n    });\n  }, 250);\n}\n\nclass Web3Contract {\n  static UPDATE_ACCOUNT = 'update:account';\n  static UPDATE_DATA = 'update:data';\n\n  _events\n  _abi\n  _callContract\n  _sendContract\n  address\n  name\n  account\n\n  constructor(abi, address, name) {\n    if (!address) {\n      throw new Error(`Invalid contract address (${name})`);\n    }\n\n    this._events = new EventEmitter();\n    this._abi = abi;\n    this.address = address;\n    this.name = name ?? address;\n\n    const web3 = new Web3();\n    this._callContract = new web3.eth.Contract(abi, address);\n    this._sendContract = new web3.eth.Contract(abi, address);\n  }\n\n  /// GETTERS\n  get writeFunctions() {\n    return this._abi.filter(r => r.type === 'function' && !r.constant);\n  }\n\n  get callProvider() {\n    return this._callContract.currentProvider;\n  }\n\n  get provider() {\n    return this._sendContract.currentProvider;\n  }\n\n  /// SETTERS\n  setCallProvider(provider) {\n    if (this._callContract.currentProvider !== provider) {\n      this._callContract.setProvider(provider);\n    }\n  }\n\n  setProvider(provider) {\n    if (this._sendContract.currentProvider !== provider) {\n      this._sendContract.setProvider(provider);\n    }\n  }\n\n  setAccount(account) {\n    if (this.account !== account) {\n      this.account = account;\n      this.emit(Web3Contract.UPDATE_ACCOUNT, account);\n    }\n  }\n\n  /// ASSERTION METHODS\n  assertAccount() {\n    if (!this.account) {\n      throw new Error('This operation requires wallet to be connected!');\n    }\n  }\n\n  /// REQUEST METHODS\n  batch(methods) {\n    if (methods.length === 0) {\n      return Promise.reject(new Error(`Empty list of methods for batch.`));\n    }\n\n    const promises = methods.map((batchMethod) => {\n      return new Promise(resolve => {\n        this.call(batchMethod.method, batchMethod.methodArgs ?? [], batchMethod.callArgs ?? {})\n          .then(value => resolve((batchMethod.transform ?? (x => x))(value)))\n          .catch(err => resolve(batchMethod.onError?.(err) ?? undefined));\n      });\n    });\n\n    return Promise.all(promises);\n  }\n\n  call(method, methodArgs = [], callArgs = {}) {\n    const contractMethod = this._callContract.methods[method];\n\n    if (!contractMethod) {\n      return Promise.reject(new Error(`Unknown method \"${method}\". (Ref. ${this.name}.${method})`));\n    }\n\n    if (!this._callContract.currentProvider) {\n      return Promise.reject(new Error(`Contract call failure. Missing call provider. (Ref. ${this.name}.${method})`));\n    }\n\n    return new Promise((resolve, reject) => {\n      const req = contractMethod(...methodArgs).call.request(callArgs, (err, value) => {\n        if (err) {\n          console.error(`Contract(${this.address}).${method}.call`, err);\n          return reject(err);\n        }\n\n        if (+value === WEB3_ERROR_VALUE) {\n          return Promise.reject(new Error(`Contract call failure. (Ref. ${this.name}.${method})`));\n        }\n\n        resolve(value);\n      });\n\n      BatchRequestManager.addRequest(this._callContract, req);\n    });\n  }\n\n  send(method, methodArgs = [], sendArgs = {}, gasPrice) {\n    this.assertAccount();\n\n    const contractMethod = this._sendContract.methods[method];\n\n    if (!contractMethod) {\n      return Promise.reject(new Error(`Unknown method \"${method}\". (Ref. ${this.name}.${method})`));\n    }\n\n    if (!this._sendContract.currentProvider) {\n      return Promise.reject(new Error(`Contract send failure. Missing send provider. (Ref. ${this.name}.${method})`));\n    }\n\n    const _sendArgs = {\n      from: this.account,\n      gasPrice: gasPrice !== undefined ? getGasValue(gasPrice) : undefined,\n      ...sendArgs,\n    };\n\n    const meta = {\n      id: uniqueId(`${method}:`),\n      sender: this,\n      method,\n      methodArgs,\n      sendArgs: _sendArgs,\n    };\n\n    return contractMethod(...methodArgs)\n      .send(_sendArgs, async (err, txHash) => {\n        if (err) {\n          return;\n        }\n\n        this.emit('tx:hash', txHash, {\n          ...meta,\n          state: 'progress',\n          txHash,\n        });\n      })\n      .then((result) => {\n        this.emit('tx:success', result, {\n          ...meta,\n          state: 'success',\n          result,\n        });\n        return result;\n      })\n      .catch((error) => {\n        (this._sendContract.currentProvider)?.emit('send::error', error);\n\n        this.emit('tx:fail', error, {\n          ...meta,\n          state: 'fail',\n          error,\n        });\n        return Promise.reject(error);\n      });\n  }\n\n  /// EVENT METHODS\n  on(event, listener) {\n    return this._events.on(event, listener);\n  }\n\n  once(event, listener) {\n    return this._events.once(event, listener);\n  }\n\n  off(event, listener) {\n    return this._events.off(event, listener);\n  }\n\n  emit(event, ...args) {\n    return this._events.emit(event, ...args);\n  }\n\n  onUpdateAccount(listener) {\n    return this.on('update:account', listener);\n  }\n\n  onUpdateData(listener) {\n    return this.on('update:data', listener);\n  }\n}\n\nexport default Web3Contract;"],"mappings":"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"},"metadata":{},"sourceType":"module"}