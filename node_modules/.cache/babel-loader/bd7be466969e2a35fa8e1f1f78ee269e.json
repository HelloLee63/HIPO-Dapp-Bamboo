{"ast":null,"code":"import { useMemo, useState, useCallback } from 'react';\nconst defaultOptions = {\n  maxSize: 100\n};\n/**\r\n * useUndoState hook\r\n * Drop in replacement for useState hook but with undo functionality.\r\n *\r\n * @typedef UndoStateOptions\r\n * @type {object}\r\n * @property {number} maxSize - Maximum number of states to keep in the undo stack.\r\n * @param {any} defaultValue - Default value to use for the state. This will be the first value in the undo stack.\r\n * @param {UseUndoStateOptions} options - Options for the undo state. Currently takes the maxSize option.\r\n * @returns {UseUndoStateReturnValue}\r\n * @see https://rooks.vercel.app/docs/useUndoState\r\n */\nconst useUndoState = (defaultValue, options) => {\n  const {\n    maxSize\n  } = useMemo(() => {\n    return Object.assign(Object.assign({}, defaultOptions), options);\n  }, [options]);\n  const [value, setValue] = useState([defaultValue]);\n  const push = useCallback(argument => {\n    return setValue(current => {\n      const restValues = current.length >= maxSize ? current.slice(0, maxSize) : current;\n      if (typeof argument === \"function\") {\n        // I dislike this type assertion, but it's the only way to get the type to match\n        // as the type guard doesn't seem to be working here.\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        return [argument(current[0]), ...restValues];\n      } else {\n        return [argument, ...restValues];\n      }\n    });\n  }, [maxSize]);\n  const undo = useCallback(() => {\n    setValue(current => {\n      if (current.length === 1) {\n        return current;\n      }\n      const [, ...values] = current;\n      return values;\n    });\n  }, []);\n  const returnValue = useMemo(() => {\n    return [value[0], push, undo];\n  }, [push, undo, value]);\n  return returnValue;\n};\nexport { useUndoState };","map":{"version":3,"names":["useMemo","useState","useCallback","defaultOptions","maxSize","useUndoState","defaultValue","options","Object","assign","value","setValue","push","argument","current","restValues","length","slice","undo","values","returnValue"],"sources":["/Users/lijinxing/Documents/hipo-dapp-bamboo/node_modules/rooks/dist/esm/hooks/useUndoState.js"],"sourcesContent":["import { useMemo, useState, useCallback } from 'react';\n\nconst defaultOptions = { maxSize: 100 };\r\n/**\r\n * useUndoState hook\r\n * Drop in replacement for useState hook but with undo functionality.\r\n *\r\n * @typedef UndoStateOptions\r\n * @type {object}\r\n * @property {number} maxSize - Maximum number of states to keep in the undo stack.\r\n * @param {any} defaultValue - Default value to use for the state. This will be the first value in the undo stack.\r\n * @param {UseUndoStateOptions} options - Options for the undo state. Currently takes the maxSize option.\r\n * @returns {UseUndoStateReturnValue}\r\n * @see https://rooks.vercel.app/docs/useUndoState\r\n */\r\nconst useUndoState = (defaultValue, options) => {\r\n    const { maxSize } = useMemo(() => {\r\n        return Object.assign(Object.assign({}, defaultOptions), options);\r\n    }, [options]);\r\n    const [value, setValue] = useState([defaultValue]);\r\n    const push = useCallback((argument) => {\r\n        return setValue((current) => {\r\n            const restValues = current.length >= maxSize ? current.slice(0, maxSize) : current;\r\n            if (typeof argument === \"function\") {\r\n                // I dislike this type assertion, but it's the only way to get the type to match\r\n                // as the type guard doesn't seem to be working here.\r\n                // eslint-disable-next-line @typescript-eslint/ban-types\r\n                return [argument(current[0]), ...restValues];\r\n            }\r\n            else {\r\n                return [argument, ...restValues];\r\n            }\r\n        });\r\n    }, [maxSize]);\r\n    const undo = useCallback(() => {\r\n        setValue((current) => {\r\n            if (current.length === 1) {\r\n                return current;\r\n            }\r\n            const [, ...values] = current;\r\n            return values;\r\n        });\r\n    }, []);\r\n    const returnValue = useMemo(() => {\r\n        return [value[0], push, undo];\r\n    }, [push, undo, value]);\r\n    return returnValue;\r\n};\n\nexport { useUndoState };\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAEtD,MAAMC,cAAc,GAAG;EAAEC,OAAO,EAAE;AAAI,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,YAAY,GAAGA,CAACC,YAAY,EAAEC,OAAO,KAAK;EAC5C,MAAM;IAAEH;EAAQ,CAAC,GAAGJ,OAAO,CAAC,MAAM;IAC9B,OAAOQ,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEN,cAAc,CAAC,EAAEI,OAAO,CAAC;EACpE,CAAC,EAAE,CAACA,OAAO,CAAC,CAAC;EACb,MAAM,CAACG,KAAK,EAAEC,QAAQ,CAAC,GAAGV,QAAQ,CAAC,CAACK,YAAY,CAAC,CAAC;EAClD,MAAMM,IAAI,GAAGV,WAAW,CAAEW,QAAQ,IAAK;IACnC,OAAOF,QAAQ,CAAEG,OAAO,IAAK;MACzB,MAAMC,UAAU,GAAGD,OAAO,CAACE,MAAM,IAAIZ,OAAO,GAAGU,OAAO,CAACG,KAAK,CAAC,CAAC,EAAEb,OAAO,CAAC,GAAGU,OAAO;MAClF,IAAI,OAAOD,QAAQ,KAAK,UAAU,EAAE;QAChC;QACA;QACA;QACA,OAAO,CAACA,QAAQ,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,GAAGC,UAAU,CAAC;MAChD,CAAC,MACI;QACD,OAAO,CAACF,QAAQ,EAAE,GAAGE,UAAU,CAAC;MACpC;IACJ,CAAC,CAAC;EACN,CAAC,EAAE,CAACX,OAAO,CAAC,CAAC;EACb,MAAMc,IAAI,GAAGhB,WAAW,CAAC,MAAM;IAC3BS,QAAQ,CAAEG,OAAO,IAAK;MAClB,IAAIA,OAAO,CAACE,MAAM,KAAK,CAAC,EAAE;QACtB,OAAOF,OAAO;MAClB;MACA,MAAM,GAAG,GAAGK,MAAM,CAAC,GAAGL,OAAO;MAC7B,OAAOK,MAAM;IACjB,CAAC,CAAC;EACN,CAAC,EAAE,EAAE,CAAC;EACN,MAAMC,WAAW,GAAGpB,OAAO,CAAC,MAAM;IAC9B,OAAO,CAACU,KAAK,CAAC,CAAC,CAAC,EAAEE,IAAI,EAAEM,IAAI,CAAC;EACjC,CAAC,EAAE,CAACN,IAAI,EAAEM,IAAI,EAAER,KAAK,CAAC,CAAC;EACvB,OAAOU,WAAW;AACtB,CAAC;AAED,SAASf,YAAY"},"metadata":{},"sourceType":"module"}