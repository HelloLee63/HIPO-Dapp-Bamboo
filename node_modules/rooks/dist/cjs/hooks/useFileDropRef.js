'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var noop = require('../utils/noop.js');
var react = require('react');
var useFreshCallback = require('./useFreshCallback.js');

/**
 * useFileDropRef
 * @description Drop files easily
 * @see {@link https://rooks.vercel.app/docs/useFileDropRef}
 */
function useFileDropRef(options = {}, callbacks = {}) {
    const { accept, maxFileSize, maxFiles } = options;
    const { onDrop = noop.noop, onFileAccepted = noop.noop, onFileRejected = noop.noop, onDragEnter = noop.noop, onDragLeave = noop.noop, } = callbacks;
    const [targetNode, setTargetNode] = react.useState(null);
    const freshOnDrop = useFreshCallback.useFreshCallback(onDrop);
    const freshOnFileAccepted = useFreshCallback.useFreshCallback(onFileAccepted);
    const freshOnFileRejected = useFreshCallback.useFreshCallback(onFileRejected);
    const freshOnDragEnter = useFreshCallback.useFreshCallback(onDragEnter);
    const freshOnDragLeave = useFreshCallback.useFreshCallback(onDragLeave);
    react.useCallback((node) => {
        setTargetNode(node);
    }, []);
    const fileIsValid = react.useCallback((file) => {
        if (accept && !accept.includes(file.type)) {
            return { valid: false, reason: "File type not allowed" };
        }
        if (maxFileSize && file.size > maxFileSize) {
            return { valid: false, reason: "File size exceeds the limit" };
        }
        return { valid: true };
    }, [accept, maxFileSize]);
    const handleDrop = react.useCallback((event) => {
        var _a;
        event.preventDefault();
        const files = Array.from(((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.files) || []);
        const acceptedFiles = [];
        const rejectedFiles = [];
        if (maxFiles && files.length > maxFiles) {
            for (const file of files) {
                freshOnFileRejected(file, "Exceeded maximum number of files");
            }
        }
        else {
            files.forEach((file) => {
                const validationResult = fileIsValid(file);
                if (validationResult.valid) {
                    acceptedFiles.push(file);
                    freshOnFileAccepted(file);
                }
                else {
                    rejectedFiles.push(file);
                    freshOnFileRejected(file, validationResult.reason || "Unknown reason");
                }
            });
        }
        freshOnDrop(acceptedFiles, rejectedFiles);
    }, [
        fileIsValid,
        freshOnFileAccepted,
        freshOnFileRejected,
        maxFiles,
        freshOnDrop,
    ]);
    const handleDragOver = react.useCallback((event) => {
        event.preventDefault();
    }, []);
    react.useEffect(() => {
        if (targetNode) {
            targetNode.addEventListener("drop", handleDrop);
            targetNode.addEventListener("dragover", handleDragOver);
            targetNode.addEventListener("dragenter", freshOnDragEnter);
            targetNode.addEventListener("dragleave", freshOnDragLeave);
            return () => {
                targetNode.removeEventListener("drop", handleDrop);
                targetNode.removeEventListener("dragover", handleDragOver);
                targetNode.removeEventListener("dragenter", freshOnDragEnter);
                targetNode.removeEventListener("dragleave", freshOnDragLeave);
            };
        }
        else {
            return () => { };
        }
    }, [
        targetNode,
        handleDrop,
        handleDragOver,
        freshOnDragEnter,
        freshOnDragLeave,
    ]);
    return react.useCallback((node) => {
        setTargetNode(node);
    }, []);
}

exports.useFileDropRef = useFileDropRef;
