'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');
var useOnWindowResize = require('./useOnWindowResize.js');
var useOnWindowScroll = require('./useOnWindowScroll.js');

/* eslint-disable id-length */
const getDimensionObject = (node) => {
    const rect = node.getBoundingClientRect();
    return {
        bottom: rect.bottom,
        height: rect.height,
        left: rect.left,
        right: rect.right,
        top: rect.top,
        width: rect.width,
        x: rect.left,
        y: rect.top,
    };
};
const noWindowReturnValue = [undefined, null, null];
/**
 * useDimensionsRef
 * @param updateOnScroll Whether to update on scroll
 * @param updateOnResize Whether to update on resize
 * @returns [React.Ref<HTMLDivElement>, UseDimensionsRefReturn, HTMLElement | null]
 * @see https://rooks.vercel.app/docs/useDimensionsRef
 */
const useDimensionsRef = ({ updateOnScroll = true, updateOnResize = true, } = {}) => {
    const [dimensions, setDimensions] = react.useState(null);
    const [node, setNode] = react.useState(null);
    const ref = react.useCallback((nodeFromCallback) => {
        setNode(nodeFromCallback);
    }, []);
    const measure = react.useCallback(() => {
        window.requestAnimationFrame(() => {
            if (node) {
                setDimensions(getDimensionObject(node));
            }
        });
    }, [node]);
    react.useLayoutEffect(() => {
        measure();
    }, [measure]);
    useOnWindowResize.useOnWindowResize(() => {
        measure();
    }, updateOnResize, true);
    useOnWindowScroll.useOnWindowScroll(() => {
        measure();
    }, updateOnScroll, true);
    if (typeof window === "undefined") {
        console.warn("useDimensionsRef: window is undefined.");
        return noWindowReturnValue;
    }
    return [ref, dimensions, node];
};

exports.useDimensionsRef = useDimensionsRef;
