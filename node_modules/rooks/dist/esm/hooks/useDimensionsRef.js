import { useState, useCallback, useLayoutEffect } from 'react';
import { useOnWindowResize } from './useOnWindowResize.js';
import { useOnWindowScroll } from './useOnWindowScroll.js';

/* eslint-disable id-length */
const getDimensionObject = (node) => {
    const rect = node.getBoundingClientRect();
    return {
        bottom: rect.bottom,
        height: rect.height,
        left: rect.left,
        right: rect.right,
        top: rect.top,
        width: rect.width,
        x: rect.left,
        y: rect.top,
    };
};
const noWindowReturnValue = [undefined, null, null];
/**
 * useDimensionsRef
 * @param updateOnScroll Whether to update on scroll
 * @param updateOnResize Whether to update on resize
 * @returns [React.Ref<HTMLDivElement>, UseDimensionsRefReturn, HTMLElement | null]
 * @see https://rooks.vercel.app/docs/useDimensionsRef
 */
const useDimensionsRef = ({ updateOnScroll = true, updateOnResize = true, } = {}) => {
    const [dimensions, setDimensions] = useState(null);
    const [node, setNode] = useState(null);
    const ref = useCallback((nodeFromCallback) => {
        setNode(nodeFromCallback);
    }, []);
    const measure = useCallback(() => {
        window.requestAnimationFrame(() => {
            if (node) {
                setDimensions(getDimensionObject(node));
            }
        });
    }, [node]);
    useLayoutEffect(() => {
        measure();
    }, [measure]);
    useOnWindowResize(() => {
        measure();
    }, updateOnResize, true);
    useOnWindowScroll(() => {
        measure();
    }, updateOnScroll, true);
    if (typeof window === "undefined") {
        console.warn("useDimensionsRef: window is undefined.");
        return noWindowReturnValue;
    }
    return [ref, dimensions, node];
};

export { useDimensionsRef };
