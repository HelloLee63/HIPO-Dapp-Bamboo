import { useState, useRef, useMemo, useEffect, useCallback } from 'react';

function getValueFromSessionStorage(key) {
    var _a;
    if (typeof sessionStorage === "undefined") {
        return null;
    }
    const storedValue = (_a = sessionStorage.getItem(key)) !== null && _a !== void 0 ? _a : "null";
    try {
        return JSON.parse(storedValue);
    }
    catch (error) {
        console.error(error);
    }
    return storedValue;
}
function saveValueToSessionStorage(key, value) {
    if (typeof sessionStorage === "undefined") {
        return null;
    }
    return sessionStorage.setItem(key, JSON.stringify(value));
}
/**
 * @param key Key of the sessionStorage object
 * @param initialState Default initial value
 */
function initialize(key, initialState) {
    const valueLoadedFromSessionStorage = getValueFromSessionStorage(key);
    if (valueLoadedFromSessionStorage === null) {
        return initialState;
    }
    else {
        return valueLoadedFromSessionStorage;
    }
}
/**
 * useSessionstorageState hook
 * Tracks a value within sessionStorage and updates it
 *
 * @param {string} key - Key of the sessionStorage object
 * @param {any} initialState - Default initial value
 * @returns {[any, Dispatch<SetStateAction<any>>, () => void]}
 * @see https://rooks.vercel.app/docs/useSessionstorageState
 */
function useSessionstorageState(key, initialState) {
    const [value, setValue] = useState(() => initialize(key, initialState));
    const isUpdateFromCrossDocumentListener = useRef(false);
    const isUpdateFromWithinDocumentListener = useRef(false);
    const customEventTypeName = useMemo(() => {
        return `rooks-${key}-sessionstorage-update`;
    }, [key]);
    useEffect(() => {
        /**
         * We need to ensure there is no loop of
         * storage events fired. Hence we are using a ref
         * to keep track of whether setValue is from another
         * storage event
         */
        if (!isUpdateFromCrossDocumentListener.current) {
            saveValueToSessionStorage(key, value);
        }
    }, [key, value]);
    const listenToCrossDocumentStorageEvents = useCallback((event) => {
        var _a;
        if (event.storageArea === sessionStorage && event.key === key) {
            try {
                isUpdateFromCrossDocumentListener.current = true;
                const newValue = JSON.parse((_a = event.newValue) !== null && _a !== void 0 ? _a : "null");
                if (value !== newValue) {
                    setValue(newValue);
                }
            }
            catch (error) {
                console.log(error);
            }
        }
    }, [key, value]);
    // check for changes across windows
    useEffect(() => {
        // eslint-disable-next-line no-negated-condition
        if (typeof window !== "undefined") {
            window.addEventListener("storage", listenToCrossDocumentStorageEvents);
            return () => {
                window.removeEventListener("storage", listenToCrossDocumentStorageEvents);
            };
        }
        else {
            console.warn("[useSessionstorageState] window is undefined.");
            return () => { };
        }
    }, [listenToCrossDocumentStorageEvents]);
    const listenToCustomEventWithinDocument = useCallback((event) => {
        try {
            isUpdateFromWithinDocumentListener.current = true;
            const { newValue } = event.detail;
            if (value !== newValue) {
                setValue(newValue);
            }
        }
        catch (error) {
            console.log(error);
        }
    }, [value]);
    // check for changes within document
    useEffect(() => {
        // eslint-disable-next-line no-negated-condition
        if (typeof document !== "undefined") {
            document.addEventListener(customEventTypeName, listenToCustomEventWithinDocument);
            return () => {
                document.removeEventListener(customEventTypeName, listenToCustomEventWithinDocument);
            };
        }
        else {
            console.warn("[useSessionstorageState] document is undefined.");
            return () => { };
        }
    }, [customEventTypeName, listenToCustomEventWithinDocument]);
    const broadcastValueWithinDocument = useCallback((newValue) => {
        // eslint-disable-next-line no-negated-condition
        if (typeof document !== "undefined") {
            const event = new CustomEvent(customEventTypeName, { detail: { newValue } });
            document.dispatchEvent(event);
        }
        else {
            console.warn("[useSessionstorageState] document is undefined.");
        }
    }, [customEventTypeName]);
    const set = useCallback((newValue) => {
        isUpdateFromCrossDocumentListener.current = false;
        isUpdateFromWithinDocumentListener.current = false;
        setValue(newValue);
        broadcastValueWithinDocument(newValue);
    }, [broadcastValueWithinDocument]);
    const remove = useCallback(() => {
        sessionStorage.removeItem(key);
    }, [key]);
    return [value, set, remove];
}

export { useSessionstorageState };
