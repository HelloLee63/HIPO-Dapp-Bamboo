import { useRef, useCallback, useEffect } from 'react';
import { useFreshRef } from './useFreshRef.js';
import { useGetIsMounted } from './useGetIsMounted.js';

/**
 * A version of useEffect that accepts an async function
 *
 * @param {Effect<T>} effect Async function that can return a cleanup function and takes in an AbortSignal
 * @param {DependencyList} deps If present, effect will only activate if the values in the list change
 * @param {CleanupFunction} cleanup The destroy/cleanup function. Will be called with previous result if it exists.
 * @see https://rooks.vercel.app/docs/useAsyncEffect
 * @example
 * ```jsx
 * useAsyncEffect(
        async (shouldContinueEffect) => {
          const data1 = await fetchData1(arg1, arg2);
          if(shouldContinueEffect()) {
            const data2 = await fetchData2(arg1, arg2);
          }
          ...
        },
        [arg1, arg2],
        (previousResult) => {
          // ... do something with previousResult ...
        }
      );
 * ```
 */
function useAsyncEffect(effect, deps, cleanup) {
    // We need to synchronize the async callback response with
    // the closure it was called in
    const lastCallId = useRef(0);
    const getIsMounted = useGetIsMounted();
    const effectRef = useFreshRef(effect);
    const callback = useCallback(async () => {
        const callId = ++lastCallId.current;
        const shouldContinueEffect = () => {
            return getIsMounted() && callId === lastCallId.current;
        };
        try {
            return await effectRef.current(shouldContinueEffect);
        }
        catch (error) {
            throw error;
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [getIsMounted, ...deps]);
    useEffect(() => {
        let result;
        callback().then((value) => {
            result = value;
        });
        return () => {
            cleanup === null || cleanup === void 0 ? void 0 : cleanup(result);
        };
    }, [callback, cleanup]);
}

export { useAsyncEffect };
