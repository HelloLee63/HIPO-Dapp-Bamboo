import { noop } from '../utils/noop.js';
import { useState, useCallback, useEffect } from 'react';
import { useFreshCallback } from './useFreshCallback.js';

/**
 * useFileDropRef
 * @description Drop files easily
 * @see {@link https://rooks.vercel.app/docs/useFileDropRef}
 */
function useFileDropRef(options = {}, callbacks = {}) {
    const { accept, maxFileSize, maxFiles } = options;
    const { onDrop = noop, onFileAccepted = noop, onFileRejected = noop, onDragEnter = noop, onDragLeave = noop, } = callbacks;
    const [targetNode, setTargetNode] = useState(null);
    const freshOnDrop = useFreshCallback(onDrop);
    const freshOnFileAccepted = useFreshCallback(onFileAccepted);
    const freshOnFileRejected = useFreshCallback(onFileRejected);
    const freshOnDragEnter = useFreshCallback(onDragEnter);
    const freshOnDragLeave = useFreshCallback(onDragLeave);
    useCallback((node) => {
        setTargetNode(node);
    }, []);
    const fileIsValid = useCallback((file) => {
        if (accept && !accept.includes(file.type)) {
            return { valid: false, reason: "File type not allowed" };
        }
        if (maxFileSize && file.size > maxFileSize) {
            return { valid: false, reason: "File size exceeds the limit" };
        }
        return { valid: true };
    }, [accept, maxFileSize]);
    const handleDrop = useCallback((event) => {
        var _a;
        event.preventDefault();
        const files = Array.from(((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.files) || []);
        const acceptedFiles = [];
        const rejectedFiles = [];
        if (maxFiles && files.length > maxFiles) {
            for (const file of files) {
                freshOnFileRejected(file, "Exceeded maximum number of files");
            }
        }
        else {
            files.forEach((file) => {
                const validationResult = fileIsValid(file);
                if (validationResult.valid) {
                    acceptedFiles.push(file);
                    freshOnFileAccepted(file);
                }
                else {
                    rejectedFiles.push(file);
                    freshOnFileRejected(file, validationResult.reason || "Unknown reason");
                }
            });
        }
        freshOnDrop(acceptedFiles, rejectedFiles);
    }, [
        fileIsValid,
        freshOnFileAccepted,
        freshOnFileRejected,
        maxFiles,
        freshOnDrop,
    ]);
    const handleDragOver = useCallback((event) => {
        event.preventDefault();
    }, []);
    useEffect(() => {
        if (targetNode) {
            targetNode.addEventListener("drop", handleDrop);
            targetNode.addEventListener("dragover", handleDragOver);
            targetNode.addEventListener("dragenter", freshOnDragEnter);
            targetNode.addEventListener("dragleave", freshOnDragLeave);
            return () => {
                targetNode.removeEventListener("drop", handleDrop);
                targetNode.removeEventListener("dragover", handleDragOver);
                targetNode.removeEventListener("dragenter", freshOnDragEnter);
                targetNode.removeEventListener("dragleave", freshOnDragLeave);
            };
        }
        else {
            return () => { };
        }
    }, [
        targetNode,
        handleDrop,
        handleDragOver,
        freshOnDragEnter,
        freshOnDragLeave,
    ]);
    return useCallback((node) => {
        setTargetNode(node);
    }, []);
}

export { useFileDropRef };
